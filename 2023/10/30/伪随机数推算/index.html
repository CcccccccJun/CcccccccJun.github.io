<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          伪随机数推算 - C12en
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>C12EN</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以往遇到的考察伪随机数的题目都相对比较简单 无非就是通过seed来推算出后续的随机数 但是这次的核心在于 seed不可控且不可知的情况下 如何通过seed生成的伪随机数 来推算出后续的随机数</p>
<h1 id="rand函数源码分析"><a href="#rand函数源码分析" class="headerlink" title="rand函数源码分析"></a>rand函数源码分析</h1><p>先来弄懂 rand函数究竟是如何通过seed来生成随机数的<br>以下代码均从 <a target="_blank" rel="noopener" href="https://codebrowser.dev/glibc/">https://codebrowser.dev/glibc/</a> 摘录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Return a random integer between 0 and RAND_MAX.  */</span><br><span class="line">int</span><br><span class="line">rand (void)</span><br><span class="line">&#123;</span><br><span class="line">  return (int) __random ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部进而调用了__random函数 跟进一下看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__random (void)</span><br><span class="line">&#123;</span><br><span class="line">  int32_t retval;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  (void) __random_r (buf: &amp;unsafe_state, result: &amp;retval);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注一下__random_r函数 unsafe_state结构体作为参数传输 返回值存储于retval</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static struct random_data unsafe_state =</span><br><span class="line">&#123;</span><br><span class="line">    /* FPTR和RPTR是指向状态信息的两个指针，一个前指针和一个后指针。</span><br><span class="line">       这两个指针始终相隔rand_sep个位置，因为它们在状态信息中循环。</span><br><span class="line">       （是的，这意味着我们可以只用一个指针，但是这种方式的random代码更高效）。</span><br><span class="line">       这两个指针的位置是从调用initstate(1, randtbl, 128)的位置开始：</span><br><span class="line">       （后指针rptr的位置实际上是0（如上面在初始化randtbl时解释的那样），</span><br><span class="line">       因为状态表指针被设置为指向randtbl[1]（如下面解释的那样）。）*/</span><br><span class="line"></span><br><span class="line">    .fptr = &amp;randtbl[SEP_3 + 1],    // SEP_3 = 3</span><br><span class="line">    .rptr = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    /* 以下内容是指向状态信息表的指针、当前生成器的类型、当前多项式的度数和两个指针之间的间隔。</span><br><span class="line">       注意，为了random的效率，我们记住状态信息的第一个位置，而不是第零个位置。</span><br><span class="line">       因此，访问state[-1]是有效的，它用于存储R.N.G.的类型。</span><br><span class="line">       另外，我们记住最后一个位置，因为这比每次索引以查找最后一个元素的地址来判断前后指针是否已经回绕更高效。 */</span><br><span class="line"></span><br><span class="line">    .state = &amp;randtbl[1],</span><br><span class="line"></span><br><span class="line">    .rand_type = TYPE_3,    // 3</span><br><span class="line">    .rand_deg = DEG_3,      // 3</span><br><span class="line">    .rand_sep = SEP_3,      // 3</span><br><span class="line"></span><br><span class="line">    .end_ptr = &amp;randtbl[sizeof(randtbl) / sizeof(randtbl[0])]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据注释可以得到 fptr和rptr是指向状态信息的前后指针 并且虽然rptr的起始是randtbl[1]但是实际上是0<br>为了理解这一描述 我们先来看一下randtbl数组的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int32_t randtbl[DEG_3 + 1] =</span><br><span class="line">&#123;</span><br><span class="line">    TYPE_3,</span><br><span class="line"></span><br><span class="line">    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,</span><br><span class="line">    1627687941, -179304937, -2073333483, 1780058412, -1989503057,</span><br><span class="line">    -615974602, 344556628, 939512070, -1249116260, 1507946756,</span><br><span class="line">    -812545463, 154635395, 1388815473, -1926676823, 525320961,</span><br><span class="line">    -1009028674, 968117788, -123449607, 1284210865, 435012392,</span><br><span class="line">    -2017506339, -911064859, -370259173, 1132637927, 1398500161,</span><br><span class="line">    -205601318</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该数组存储着内部状态信息 用于随机数的生成<br>通过randtbl数组的注释 我们可以得知上文中 后指针的位置为0的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initially, everything is set up as if from: ↪</span><br><span class="line">	initstate(1, randtbl, 128); ↪</span><br><span class="line">   Note that this initialization takes advantage of the fact that srandom ↪</span><br><span class="line">   advances the front and rear pointers 10*rand_deg times, and hence the ↪</span><br><span class="line">   rear pointer which starts at 0 will also end up at zero; thus the zeroth ↪</span><br><span class="line">   element of the state information, which contains info about the current ↪</span><br><span class="line">   position of the rear pointer is just ↪</span><br><span class="line">	(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.</span><br></pre></td></tr></table></figure>
<p>后指针在初始化的时候指向第一个元素 所以第一个元素存储的是后指针当前位置的信息<br>接着我们回到unsafe_state结构体<br>其还定义了其他成员 用来记录生成器类型 随机次数 随机间隔<br>此外还记录了最后一个元素的位置<br>接下来分析一下__random_r函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int __random_r(struct random_data *buf, int32_t *result)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t *state;</span><br><span class="line"></span><br><span class="line">    if (buf == NULL || result == NULL)</span><br><span class="line">        goto fail;</span><br><span class="line"></span><br><span class="line">    state = buf-&gt;state;</span><br><span class="line"></span><br><span class="line">    if (buf-&gt;rand_type == TYPE_0)</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        state[0] = val;</span><br><span class="line">        *result = val;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t *fptr = buf-&gt;fptr;</span><br><span class="line">        int32_t *rptr = buf-&gt;rptr;</span><br><span class="line">        int32_t *end_ptr = buf-&gt;end_ptr;</span><br><span class="line">        uint32_t val;</span><br><span class="line"></span><br><span class="line">        val = *fptr += (uint32_t)*rptr;</span><br><span class="line">        /* Chucking least random bit. */</span><br><span class="line">        *result = val &gt;&gt; 1;</span><br><span class="line">        ++fptr;</span><br><span class="line">        if (fptr &gt;= end_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            fptr = state;</span><br><span class="line">            ++rptr;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ++rptr;</span><br><span class="line">            if (rptr &gt;= end_ptr)</span><br><span class="line">                rptr = state;</span><br><span class="line">        &#125;</span><br><span class="line">        buf-&gt;fptr = fptr;</span><br><span class="line">        buf-&gt;rptr = rptr;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    __set_errno(EINVAL);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考注释可以得知 生成器有两种类型 TYPE_0是使用旧的线性同余法  另外一个则是使用精巧三项式算法<br>先来看较为简单的前者 state[0]指向randtbl数组的第二个元素 将其乘以1103515245 U代表无符号整数 随后加上12345 最后进行与运算<br>这里清空了符号位 并且只保留低31位<br>随后更新state[0]以及result</p>
<p>接下来看后者<br>开始先将结构体的成员赋值给对应的局部变量(下面 前指针和后指针所指向的数值 为了方便描述 均采用缩写为前后指针<br>接着将后指针加上前指针 其和重新赋值给了前指针以及val变量<br>随后的注释比较耐人寻味 其说舍弃最不随机的位<br>下一条指令对val右移了一位 相当于val除2 结果取整<br>这里说的最不随机的位指的是最低1位<br>就拿线性同余运算举例<br>其运算式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = ((state[0] * 1103515245U) + 12345U) &amp; 0x7fffffff</span><br></pre></td></tr></table></figure>
<p>这里使用state[0]默认的值379960547代入<br>可以编写这样一个测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int32_t state = 379960547;</span><br><span class="line">    int32_t val =0;</span><br><span class="line">    int time=1;</span><br><span class="line">    int bit =0;</span><br><span class="line">    for(int i=0;i&lt;20;i++)&#123;</span><br><span class="line">        val = ((state * 1103515245U) + 12345U) &amp; 0x7fffffff;</span><br><span class="line">        bit = val&amp;1;</span><br><span class="line">        state = val;</span><br><span class="line">        printf(&quot;count :%d ,val :%d,last bit: %d\n&quot;,time,val,bit);</span><br><span class="line">        time ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后得到的结果为<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310312226443.png" alt="image.png"><br>可以看到最后一个bit为0和1交替 呈现出一定规律 所以称之为最不随机的位<br>说回正文 在进行了右移运算后 自增了前指针<br>如果前指针超过了数组的最后一个元素 那么就重置前指针 使其重新指向randtbl数组的第二个元素<br>如果没有超过 再自增后指针 如果后指针超过 那么就重置后指针 同上</p>
<h1 id="如何预测随机数"><a href="#如何预测随机数" class="headerlink" title="如何预测随机数"></a>如何预测随机数</h1><p>经过上面的源码分析<br>可以大概清楚随机数的生成逻辑<br>state数组从randtbl数组的第二个元素开始 也就是说state一共有31个元素<br>前指针初始指向s[3] (这里将state数组缩写成s)<br>后指针初始指向s[0]<br>那么我们这里就可以得到随机数数组o的第一个元素为<br>o[0] &#x3D; (s[3]+s[0])&gt;&gt;1<br>随后前指针和后指针均自增<br>随着推移 前指针会率先来到s数组的最后一个元素s[30]<br>根据源码推断 超过了s[30]后 就会重新赋值成s[0]<br>但是这里要注意 在随机数生成后 后指针与前指针之和会赋值给前指针<br>所以我们这里的s[?]只是一个代号 而非具体的值<br>也就是o[28] &#x3D; (s[0]+s[28])&gt;&gt;1<br>同理 o[31] &#x3D; (s[3]+s[0])&gt;&gt;1<br>如果拆分开成 s[3]&#x3D;s[3]+s[0],s[0] &#x3D; s[0]+s[28]<br>o[31]的值就有两种可能性<br>第一种为o[31] &#x3D; o[0]+o[28]<br>第二种为o[31] &#x3D; o[0]+o[28]+1<br>见下面表格</p>
<table>
<thead>
<tr>
<th>s[0]</th>
<th>s[3]</th>
<th>s[28]</th>
<th>o[31]</th>
</tr>
</thead>
<tbody><tr>
<td>奇</td>
<td>奇</td>
<td>奇</td>
<td>1</td>
</tr>
<tr>
<td>奇</td>
<td>奇</td>
<td>偶</td>
<td>1</td>
</tr>
<tr>
<td>奇</td>
<td>偶</td>
<td>奇</td>
<td>1</td>
</tr>
<tr>
<td>偶</td>
<td>奇</td>
<td>奇</td>
<td>2</td>
</tr>
<tr>
<td>奇</td>
<td>偶</td>
<td>偶</td>
<td>2</td>
</tr>
<tr>
<td>偶</td>
<td>偶</td>
<td>奇</td>
<td>1</td>
</tr>
<tr>
<td>偶</td>
<td>偶</td>
<td>偶</td>
<td>1</td>
</tr>
</tbody></table>
<p>可以看出是第一种可能性的概率为七分之五<br>也就是说 如果我们得到了o[0]和o[28] 我们就有比较大的概率预测出o[31]<br>同理 可以继续往下推  o[1]和o[29] 可得出o[32]等等<br>o[n] &#x3D; o[n-31]+o[n-3]或o[n] &#x3D; o[n-31]+o[n-3]+1<br>由于本人数学水平不高 所以无法想出怎么百分百预测 感兴趣的可以自己尝试(顺顺教教我</p>
<h1 id="实际演示"><a href="#实际演示" class="headerlink" title="实际演示"></a>实际演示</h1><p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041006599.png" alt="image.png"><br>以上面这题来举例 seed无法得知也无法覆盖<br>一共有101次机会<br>在猜数错误后 会提供正确的随机数<br>所以我们只需要保留o[0]和o[28]<br>就可以得出第32个随机数o[31]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">o = []</span><br><span class="line">buf = 0</span><br><span class="line">for i in range(31):</span><br><span class="line">    io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">    io.sendline(b&#x27;0&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;Here is some knowledge to help you become powerful...: &#x27;)</span><br><span class="line">    c = int(io.recvuntil(&quot;\n&quot;,drop = True))</span><br><span class="line">    o.append(c)</span><br><span class="line">buf = o[0]+o[28]</span><br><span class="line">print(buf)</span><br><span class="line">io.recvuntil(&quot;Knowledge is power, not luck.\n&quot;)</span><br><span class="line">io.sendline(str(buf))</span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202311041009081.png" alt="image.png"><br>成功得到正确的数值</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="C"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>C12en</div>
      <div>2023-10-30</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/extra/">extra</a>

      
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
