<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Fuzzing: Art, Science, and Engineering论文阅读 - C12en
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>C12EN</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <p>原论文地址:<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a><br>由于本人的英文水平实在是太垃圾了 所以用的是谷歌机翻看的<br>部分语句可能由于机翻带来的影响导致语义错误</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>模糊测试是一种概念简单 部署门槛低 且成效显著的漏洞发现技术<br>本文的目的旨在帮助保存大量的模糊测试样例以及保证其连贯性 提出一个统一的通用模型</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者简单介绍了fuzz是什么 以及此前其存在的缺陷 同时举了几个比赛队伍或者厂商使用FUZZ的案例  随后简要概括了fuzz社区的规模<br>因为fuzz的逐渐发展 导致了各种fuzz工具之间的术语存在明显的“歧义”(fragmentation)<br>作者认为 这种歧义很有可能会阻碍fuzz的传播  影响到fuzz的发展<br>所以 其认为有必要巩固和提炼模糊测试的进展 </p>
<h1 id="SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS"><a href="#SYSTEMIZATION-TAXONOMY-AND-TEST-PRO-GRAMS" class="headerlink" title="SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS"></a>SYSTEMIZATION, TAXONOMY, AND TEST PRO-GRAMS</h1><p>介绍了模糊测试最开始的提出者以及其最开始的定义 列举了模糊测试可适用的领域 接着为了使得大量模糊测试文献中的用语系统化 作者决定介绍一个由现代用途中提取的术语</p>
<h2 id="1-Fuzzing-Fuzz-Testing"><a href="#1-Fuzzing-Fuzz-Testing" class="headerlink" title="1.Fuzzing &amp; Fuzz Testing"></a>1.Fuzzing &amp; Fuzz Testing</h2><p>本小节针对模糊测试下了第一个定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Definition 1 (Fuzzing). Fuzzing is the execution of the PUTusing input(s) sampled from an input space (the “fuzz inputspace”) that protrudes the expected input space of the PUT.</span><br><span class="line">这里的put是program under test</span><br></pre></td></tr></table></figure>
<p>此外还针对fuzz testing和fuzz进行了一个定义<br>作者认为fuzz testing是一种利用fuzz的软件测试技术 其的特定目标是用来查找和安全有关的错误 包括程序崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Definition 2 (Fuzz Testing). Fuzz testing is the use of fuzzing</span><br><span class="line">to test if a PUT violates a security policy.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Definition 3 (Fuzzer). A fuzzer is a program that performs</span><br><span class="line">fuzz testing on a PUT.</span><br></pre></td></tr></table></figure>
<p>此外还定义了fuzz compaign</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Definition 4 (Fuzz Campaign). A fuzz campaign is a specific</span><br><span class="line">execution of a fuzzer on a PUT with a specific security</span><br><span class="line">policy.</span><br></pre></td></tr></table></figure>
<p>早期的模糊测试活动 其安全策略只局限于测试输入 使PUT崩溃 但是模糊测试活动可以用于测试执行中观察到的任何安全策略 而这一决定执行是否违反安全策略的称为漏洞预测器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Definition 5 (Bug Oracle). A bug oracle is a program, per-</span><br><span class="line">haps as part of a fuzzer, that determines whether a given</span><br><span class="line">execution of the PUT violates a specific security policy.</span><br></pre></td></tr></table></figure>
<p>这一段话有点没看懂 目前还不能理解执行中观察到的任何安全策略的含义 除了输入点可以诱发的崩溃 还有什么呢 笔者于这里提出了第一个疑问<br>作者称由模糊器实现的算法为模糊算法 模糊参数是依赖于PUT之外的一些参数 称其为模糊配置 笔者这里将其理解为 模糊参数于PUT不相干 是否可以认为是一种用于模糊测试的语料库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Definition 6 (Fuzz Configuration). A fuzz configuration of</span><br><span class="line">a fuzz algorithm comprises the parameter value(s) that</span><br><span class="line">control(s) the fuzz algorithm.</span><br></pre></td></tr></table></figure>
<p>接着针对模糊算法进行了进一步的说明 作者认为模糊算法的定义是广泛的 复杂的模糊配置会随着时间的推移而演变其算法 引入了突变率和种子的概念<br>种子是用来生成输入PUT的测试用例<br>而种子的集合则成为种子池 复杂的模糊配置就会演变种子池<br>作者举了一个基于覆盖率引导的模糊测试例子 其会在每个配置中存储已经达到的覆盖率信息<br>笔者这里经过查阅资料(其实是询问gpt 大致了解了覆盖率是一种什么概念<br>覆盖率引导是一种模糊测试的技术策略 其主要目的是用来寻找最优的测试用例 该测试用例可以经过最多的代码分支 经过的代码占总代码的百分比就是覆盖率<br>那么这里就是一种迭代的过程 会根据上一次的模糊测试返回的覆盖率 来决定下一次的种子 从而使其获得更大的覆盖率</p>
<h2 id="2-Paper-Selection-Criteria"><a href="#2-Paper-Selection-Criteria" class="headerlink" title="2.Paper Selection Criteria"></a>2.Paper Selection Criteria</h2><p>这一小节 主要是作者声明了收纳出版物的范围 举了几个会议的名称<br>同时引入了黑盒白盒的概念(并未由作者提出 为笔者根据段落大意可以看出)<br>作者认为 以安全为特定目标的模糊测试和软件测试相比 从理论来说 二者的不同点只体现在漏洞预测器的区别(bug oracle)<br>接着作者提到 在实际中 软件测试的前提是知晓源代码 而且测试人对于PUT有更多的了解<br>而模糊测试更可能是被PUT开发者以外的人使用 其不知晓上述信息<br>由于这二者领域仍然密切相关 所以作者决定 只要出版物出现模糊(fuzz)一次 就纳入其中</p>
<h2 id="3-Fuzz-Testing-Algorithm"><a href="#3-Fuzz-Testing-Algorithm" class="headerlink" title="3.Fuzz Testing Algorithm"></a>3.Fuzz Testing Algorithm</h2><p>本节作者提供了一个算法1<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202310192020010.png" alt="image.png"><br>其采用一组模糊配置C以及Tlimit(最大时间限制)作为输入<br>输出一组已发现的错误<br>其由两部分组成 第一部分为预处理(preprocess)函数构成 该函数在模糊测试开始时执行<br>第二部分为由五个功能组成的循环 但不是所有的模糊器都全是这五个功能<br>称这个循环的每次运行为模糊迭代 每次inputeval将模糊样例输入给PUT称为模糊运行</p>
<h3 id="PREPROCESS-C-C"><a href="#PREPROCESS-C-C" class="headerlink" title="PREPROCESS(C)-&gt;C"></a>PREPROCESS(C)-&gt;C</h3><p>用户向P提供一组模糊配置 其可能返回一组已修改的模糊配置<br>根据模糊算法的不同 P可以执行各种各样的操作 比如插入测试代码到PUT中<br>或者测量种子文件的执行速度</p>
<h3 id="SCHEDULE-C-Telapsed-Tlimit-conf"><a href="#SCHEDULE-C-Telapsed-Tlimit-conf" class="headerlink" title="SCHEDULE(C,Telapsed,Tlimit)-&gt;conf"></a>SCHEDULE(C,Telapsed,Tlimit)-&gt;conf</h3><p>将一组模糊配置C 最大时间限制 经过的时间作为参数输入 其会返回一个用于当前模糊迭代的模糊配置<br>这句话笔者有点没看懂 是意味着该功能负责实现模糊配置的迭代?<br>不过作者说详细看2.4节 所以这里暂且留一个疑问</p>
<h3 id="INPUTGEN-conf-tcs"><a href="#INPUTGEN-conf-tcs" class="headerlink" title="INPUTGEN(conf)-&gt;tcs"></a>INPUTGEN(conf)-&gt;tcs</h3><p>这个功能输入一个当前模糊配置 根据模糊器的不同 会选择模糊配置中的种子 又或者是模型或语法作为参数 以此来输出模糊测试的样例<br>笔者这里对于模型和语法是什么东西 还没有概念 先继续往下看</p>
<h3 id="INPUTEVAL-conf-tcs-0bug-B-execinfos"><a href="#INPUTEVAL-conf-tcs-0bug-B-execinfos" class="headerlink" title="INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos"></a>INPUTEVAL(conf,tcs,0bug)-&gt;B,execinfos</h3><p>接收当前模糊配置conf 模糊测试样例 以及漏洞预测器作为参数<br>该功能用于判断PUT是否违反了安全策略<br>结束后会输出一个漏洞合集B 以及execinfos 用来迭代模糊配置</p>
<h3 id="CONFUPDATE-C-conf-execinfos-C"><a href="#CONFUPDATE-C-conf-execinfos-C" class="headerlink" title="CONFUPDATE(C,conf,execinfos)-&gt;C"></a>CONFUPDATE(C,conf,execinfos)-&gt;C</h3><p>接收模糊配置C 当前模糊配置conf execinfos作为参数<br>该功能用来更新模糊配置C</p>
<h3 id="CONTINUE-C-True-False"><a href="#CONTINUE-C-True-False" class="headerlink" title="CONTINUE(C)-&gt;{True,False}"></a>CONTINUE(C)-&gt;{True,False}</h3><p>该功能用来接收当前模糊配置 并且进行判断是否进行模糊迭代<br>如果没有新的路径可发现 其就可以终止执行</p>
<h2 id="4-Taxonomy-of-Fuzzers"><a href="#4-Taxonomy-of-Fuzzers" class="headerlink" title="4.Taxonomy of Fuzzers"></a>4.Taxonomy of Fuzzers</h2><p>本节 作者对于模糊器的分类进行了定义 分为了三种 黑盒 白盒 灰盒<br>同时 这与传统的软件测试分类不同 灰盒是作为白盒的变体</p>
<h3 id="Black-box-Fuzzer"><a href="#Black-box-Fuzzer" class="headerlink" title="Black-box Fuzzer"></a>Black-box Fuzzer</h3><p>黑盒适用于模糊测试以及软件测试中 表示测试者无法看到PUT的内部结构 只能看到PUT的输入输出 大部分的模糊器都属于这一类<br>现代的部分模糊器 在考虑输入的结构信息以此来生成更有意义的测试样例的同时 也会保证不检查PUT</p>
<h3 id="White-box-Fuzzer"><a href="#White-box-Fuzzer" class="headerlink" title="White-box Fuzzer"></a>White-box Fuzzer</h3><p>白盒测试是指在进行模糊测试的时候 已经了解了PUT的内部结构和逻辑<br>接着作者提到 白盒测试一词最早的提及是动态符号执行DSE<br>普通的符号执行是指利用符号值而非输入值来分析执行路径<br>而动态符号执行中 符号执行和具体执行路径同时运行 根据PUT的状态和具体输入的数据来简化符号约束条件<br>在简化符号约束条件中 可以将符号值转化为具体的值 例如将符号执行的系统调用转化为实际的系统调用<br>上述的符号值表示的概念 按笔者的理解 应该是用例如符号’a’这样的字符来代替具体的值例如’6’ 类似于数学中一元方程的x<br>随后 作者还提到 白盒测试通常来用来描述污点分析的模糊器<br>笔者查询得知 污点分析中的污点是指不受信任的输入源进入PUT的数据 通常是用户输入<br>通过模糊器生成污点数据 可以模拟潜在的攻击场景 检测PUT是否在处理污点数据的时候存在安全隐患<br>作者提到 由于白盒测试需要进行动态检测和smt求解 所以相比黑盒测试 所需要的开销会更多</p>
<h3 id="Grey-box-Fuzzer"><a href="#Grey-box-Fuzzer" class="headerlink" title="Grey-box Fuzzer"></a>Grey-box Fuzzer</h3><p>灰盒测试位于白盒和黑盒之间  模糊器可以获得PUT的一部分内部信息<br>与白盒模糊器相比 灰盒不会推理PUT的完整语义<br>笔者认为 这里的完整语义是指 PUT的内部逻辑 数据流 控制流以及外部的交互等等<br>作者提到 灰盒测试可以对PUT进行轻量的静态分析或者收集其执行的动态信息 比如代码覆盖率</p>
<h2 id="5-Fuzzer-Genealogy-and-Overview"><a href="#5-Fuzzer-Genealogy-and-Overview" class="headerlink" title="5.Fuzzer Genealogy and Overview"></a>5.Fuzzer Genealogy and Overview</h2><p>暂时看不下去了 断更。。。</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="C"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>C12en</div>
      <div>2023-10-17</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/extra/">extra</a>

      
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
